### 射线与三角形相交(Moller Trumbore Algorithm)
> http://blog.palmtrees.cn/moller-trumbore-algorithm/#Reference
> https://blog.csdn.net/zhanxi1992/article/details/109903792
> https://www.blurredcode.com/2020/04/%E7%9B%B4%E7%BA%BF%E4%B8%8E%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9B%B8%E4%BA%A4moller-trumbore%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC/

考虑三角形的重心坐标表示，设三角形内的一个点$(u,v)$，有:
$$
Triangle(u,v) = (1-u-u)V_0 + uV_1+vV_2
$$

设光线表示$R(t) = o+t \vec d$  ，联立上述方程得:
$$
o+t \vec d = (1-u-u)V_0 + uV_1+vV_2
$$

整理得:
$$
-t\vec{d} + (V_1-V_0)u+(V_2-V_0)v = o-V_0
$$

考虑将线性方程写成矩阵的形式:
$$
 \begin{bmatrix}
  -\vec{d}, &V_1-V_0, & V_2-V_0
  \end{bmatrix}
 \begin{bmatrix}
  t\\
  u \\
  v
  \end{bmatrix}
  = o-V_0
$$

设:
$$
\begin {aligned}
  -D &= -\vec{d} \\
  S &= o-V_0 \\
    E_1 &=V_1-V_0 \\
  E_2 &= V_2-V_0 \\
  \end {aligned}
$$

重新将等式整理得:
$$
 \begin{bmatrix}
  -D & E_1 & E_2
  \end{bmatrix}
   \begin{bmatrix}
  t\\
  u \\
  v
  \end{bmatrix}
  = S
$$


根据克莱姆法则（Cramer's Rule）可解得:
$$
 \begin{bmatrix}
  t\\
  u \\
  v
  \end{bmatrix} =
  \frac{1}{|-D,E_1,E_2|}
  \begin{bmatrix}
    S & E_1 & E_2\\
    -D & S & E_2\\
    -D & E_1 & S\\
  \end{bmatrix}
$$

已知:
$$
 \begin {aligned}
|A,B,C| &= A\times B \cdot C \\
        &= -A\times C \cdot B \\
        &= -C\times B \cdot A
  \end {aligned}
$$

因此，设$ S_1=D\times E_2,S_2= S\times E_1$，带入得:
$$
 \begin{bmatrix}
  t\\
  u \\
  v
  \end{bmatrix} =
  \frac{1}{S_1 \cdot E_1}
  \begin{bmatrix}
    S_2\cdot E_2\\
    S_1\cdot S\\
    S_2\cdot D\\
  \end{bmatrix}
$$

光线与三角形有交点当且仅当 $t \geq 0,u \geq 0,(1-u-v) \geq 0$.

代码实现:
```c++
bool rayTriangleIntersect(
  const Vector3f& v0,
  const Vector3f& v1,
  const Vector3f& v2,
  const Vector3f& orig,
  const Vector3f& dir,
  float& tnear,
  float& u,
  float& v)
{
    bool isIn = false;
    Vector3f E1 = v1 - v0;
    Vector3f E2 = v2 - v0;
    Vector3f S = orig - v0;
    Vector3f S1 = crossProduct(dir, E2);
    Vector3f S2 = crossProduct(S, E1);
    float coeff = 1.0 / dotProduct(S1, E1); // 共同系数
    float t = coeff * dotProduct(S2, E2);
    float b1 = coeff * dotProduct(S1, S);
    float b2 = coeff * dotProduct(S2, dir);
    if (t >= 0 && b1 >= 0 && b2 >= 0 && (1 - b1 - b2) >= 0)
    {
        isIn = true;
        tnear = t;
        u = b1;
        v = b2;
    }

    return isIn;
}
```
